/*.cc generated by asdl*/

#include "python_ast.h"

auto mod_ty::Module()->decltype(&v.Module){
    assert(kind==ModuleKind);
    return &v.Module;
}
auto mod_ty::Interactive()->decltype(&v.Interactive){
    assert(kind==InteractiveKind);
    return &v.Interactive;
}
auto mod_ty::Expression()->decltype(&v.Expression){
    assert(kind==ExpressionKind);
    return &v.Expression;
}
auto stmt_ty::FunctionDef()->decltype(&v.FunctionDef){
    assert(kind==FunctionDefKind);
    return &v.FunctionDef;
}
auto stmt_ty::ClassDef()->decltype(&v.ClassDef){
    assert(kind==ClassDefKind);
    return &v.ClassDef;
}
auto stmt_ty::Return()->decltype(&v.Return){
    assert(kind==ReturnKind);
    return &v.Return;
}
auto stmt_ty::Assign()->decltype(&v.Assign){
    assert(kind==AssignKind);
    return &v.Assign;
}
auto stmt_ty::AugAssign()->decltype(&v.AugAssign){
    assert(kind==AugAssignKind);
    return &v.AugAssign;
}
auto stmt_ty::For()->decltype(&v.For){
    assert(kind==ForKind);
    return &v.For;
}
auto stmt_ty::While()->decltype(&v.While){
    assert(kind==WhileKind);
    return &v.While;
}
auto stmt_ty::If()->decltype(&v.If){
    assert(kind==IfKind);
    return &v.If;
}
auto stmt_ty::Expr()->decltype(&v.Expr){
    assert(kind==ExprKind);
    return &v.Expr;
}
auto stmt_ty::Nonlocal()->decltype(&v.Nonlocal){
    assert(kind==NonlocalKind);
    return &v.Nonlocal;
}
auto stmt_ty::Global()->decltype(&v.Global){
    assert(kind==GlobalKind);
    return &v.Global;
}
auto expr_ty::BoolOp()->decltype(&v.BoolOp){
    assert(kind==BoolOpKind);
    return &v.BoolOp;
}
auto expr_ty::BinOp()->decltype(&v.BinOp){
    assert(kind==BinOpKind);
    return &v.BinOp;
}
auto expr_ty::UnaryOp()->decltype(&v.UnaryOp){
    assert(kind==UnaryOpKind);
    return &v.UnaryOp;
}
auto expr_ty::Compare()->decltype(&v.Compare){
    assert(kind==CompareKind);
    return &v.Compare;
}
auto expr_ty::Call()->decltype(&v.Call){
    assert(kind==CallKind);
    return &v.Call;
}
auto expr_ty::Name()->decltype(&v.Name){
    assert(kind==NameKind);
    return &v.Name;
}
auto expr_ty::NameConstant()->decltype(&v.NameConstant){
    assert(kind==NameConstantKind);
    return &v.NameConstant;
}
auto expr_ty::Tuple()->decltype(&v.Tuple){
    assert(kind==TupleKind);
    return &v.Tuple;
}
auto expr_ty::List()->decltype(&v.List){
    assert(kind==ListKind);
    return &v.List;
}
auto expr_ty::ListComp()->decltype(&v.ListComp){
    assert(kind==ListCompKind);
    return &v.ListComp;
}
auto expr_ty::Attribute()->decltype(&v.Attribute){
    assert(kind==AttributeKind);
    return &v.Attribute;
}
auto expr_ty::Subscript()->decltype(&v.Subscript){
    assert(kind==SubscriptKind);
    return &v.Subscript;
}
auto expr_ty::IfExpr()->decltype(&v.IfExpr){
    assert(kind==IfExprKind);
    return &v.IfExpr;
}
auto expr_ty::Dict()->decltype(&v.Dict){
    assert(kind==DictKind);
    return &v.Dict;
}
auto expr_ty::Yield()->decltype(&v.Yield){
    assert(kind==YieldKind);
    return &v.Yield;
}
auto expr_ty::Num()->decltype(&v.Num){
    assert(kind==NumKind);
    return &v.Num;
}
auto expr_ty::Str()->decltype(&v.Str){
    assert(kind==StrKind);
    return &v.Str;
}
auto slice_ty::Slice()->decltype(&v.Slice){
    assert(kind==SliceKind);
    return &v.Slice;
}
auto slice_ty::ExtSlice()->decltype(&v.ExtSlice){
    assert(kind==ExtSliceKind);
    return &v.ExtSlice;
}
auto slice_ty::Index()->decltype(&v.Index){
    assert(kind==IndexKind);
    return &v.Index;
}
mod_ty *Module(asdl_seq<stmt_ty*> *body,string_ty *docstring){
    auto *ptr=new mod_ty();
    ptr->kind=ModuleKind;
    ptr->v.Module.body=body;
    ptr->v.Module.docstring=docstring;
    return ptr;
};
mod_ty *Interactive(asdl_seq<stmt_ty*> *body){
    auto *ptr=new mod_ty();
    ptr->kind=InteractiveKind;
    ptr->v.Interactive.body=body;
    return ptr;
};
mod_ty *Expression(expr_ty *body){
    assert(body!=nullptr);
    auto *ptr=new mod_ty();
    ptr->kind=ExpressionKind;
    ptr->v.Expression.body=body;
    return ptr;
};
stmt_ty *FunctionDef(identifier_ty *name,arguments_ty *args,asdl_seq<stmt_ty*> *body,int lineno,int col_offset){
    assert(name!=nullptr);
    assert(args!=nullptr);
    auto *ptr=new stmt_ty();
    ptr->kind=FunctionDefKind;
    ptr->v.FunctionDef.name=name;
    ptr->v.FunctionDef.args=args;
    ptr->v.FunctionDef.body=body;
    ptr->lineno=lineno;
    ptr->col_offset=col_offset;
    return ptr;
};
stmt_ty *ClassDef(identifier_ty *name,asdl_seq<expr_ty*> *bases,asdl_seq<stmt_ty*> *body,int lineno,int col_offset){
    assert(name!=nullptr);
    auto *ptr=new stmt_ty();
    ptr->kind=ClassDefKind;
    ptr->v.ClassDef.name=name;
    ptr->v.ClassDef.bases=bases;
    ptr->v.ClassDef.body=body;
    ptr->lineno=lineno;
    ptr->col_offset=col_offset;
    return ptr;
};
stmt_ty *Return(expr_ty *value,int lineno,int col_offset){
    auto *ptr=new stmt_ty();
    ptr->kind=ReturnKind;
    ptr->v.Return.value=value;
    ptr->lineno=lineno;
    ptr->col_offset=col_offset;
    return ptr;
};
stmt_ty *Assign(asdl_seq<expr_ty*> *targets,expr_ty *value,int lineno,int col_offset){
    assert(value!=nullptr);
    auto *ptr=new stmt_ty();
    ptr->kind=AssignKind;
    ptr->v.Assign.targets=targets;
    ptr->v.Assign.value=value;
    ptr->lineno=lineno;
    ptr->col_offset=col_offset;
    return ptr;
};
stmt_ty *AugAssign(expr_ty *target,operator_ty *op,expr_ty *value,int lineno,int col_offset){
    assert(target!=nullptr);
    assert(op!=nullptr);
    assert(value!=nullptr);
    auto *ptr=new stmt_ty();
    ptr->kind=AugAssignKind;
    ptr->v.AugAssign.target=target;
    ptr->v.AugAssign.op=op;
    ptr->v.AugAssign.value=value;
    ptr->lineno=lineno;
    ptr->col_offset=col_offset;
    return ptr;
};
stmt_ty *For(expr_ty *target,expr_ty *iter,asdl_seq<stmt_ty*> *body,asdl_seq<stmt_ty*> *orelse,int lineno,int col_offset){
    assert(target!=nullptr);
    assert(iter!=nullptr);
    auto *ptr=new stmt_ty();
    ptr->kind=ForKind;
    ptr->v.For.target=target;
    ptr->v.For.iter=iter;
    ptr->v.For.body=body;
    ptr->v.For.orelse=orelse;
    ptr->lineno=lineno;
    ptr->col_offset=col_offset;
    return ptr;
};
stmt_ty *While(expr_ty *test,asdl_seq<stmt_ty*> *body,asdl_seq<stmt_ty*> *orelse,int lineno,int col_offset){
    assert(test!=nullptr);
    auto *ptr=new stmt_ty();
    ptr->kind=WhileKind;
    ptr->v.While.test=test;
    ptr->v.While.body=body;
    ptr->v.While.orelse=orelse;
    ptr->lineno=lineno;
    ptr->col_offset=col_offset;
    return ptr;
};
stmt_ty *If(expr_ty *test,asdl_seq<stmt_ty*> *body,asdl_seq<stmt_ty*> *orelse,int lineno,int col_offset){
    assert(test!=nullptr);
    auto *ptr=new stmt_ty();
    ptr->kind=IfKind;
    ptr->v.If.test=test;
    ptr->v.If.body=body;
    ptr->v.If.orelse=orelse;
    ptr->lineno=lineno;
    ptr->col_offset=col_offset;
    return ptr;
};
stmt_ty *Expr(expr_ty *value,int lineno,int col_offset){
    assert(value!=nullptr);
    auto *ptr=new stmt_ty();
    ptr->kind=ExprKind;
    ptr->v.Expr.value=value;
    ptr->lineno=lineno;
    ptr->col_offset=col_offset;
    return ptr;
};
stmt_ty *Nonlocal(asdl_seq<identifier_ty*> *names,int lineno,int col_offset){
    auto *ptr=new stmt_ty();
    ptr->kind=NonlocalKind;
    ptr->v.Nonlocal.names=names;
    ptr->lineno=lineno;
    ptr->col_offset=col_offset;
    return ptr;
};
stmt_ty *Global(asdl_seq<identifier_ty*> *names,int lineno,int col_offset){
    auto *ptr=new stmt_ty();
    ptr->kind=GlobalKind;
    ptr->v.Global.names=names;
    ptr->lineno=lineno;
    ptr->col_offset=col_offset;
    return ptr;
};
stmt_ty *Pass(int lineno,int col_offset){
    auto *ptr=new stmt_ty();
    ptr->kind=PassKind;
    ptr->lineno=lineno;
    ptr->col_offset=col_offset;
    return ptr;
};
stmt_ty *Break(int lineno,int col_offset){
    auto *ptr=new stmt_ty();
    ptr->kind=BreakKind;
    ptr->lineno=lineno;
    ptr->col_offset=col_offset;
    return ptr;
};
stmt_ty *Continue(int lineno,int col_offset){
    auto *ptr=new stmt_ty();
    ptr->kind=ContinueKind;
    ptr->lineno=lineno;
    ptr->col_offset=col_offset;
    return ptr;
};
expr_ty *BoolOp(boolop_ty *op,asdl_seq<expr_ty*> *values,int lineno,int col_offset){
    assert(op!=nullptr);
    auto *ptr=new expr_ty();
    ptr->kind=BoolOpKind;
    ptr->v.BoolOp.op=op;
    ptr->v.BoolOp.values=values;
    ptr->lineno=lineno;
    ptr->col_offset=col_offset;
    return ptr;
};
expr_ty *BinOp(expr_ty *left,operator_ty *op,expr_ty *right,int lineno,int col_offset){
    assert(left!=nullptr);
    assert(op!=nullptr);
    assert(right!=nullptr);
    auto *ptr=new expr_ty();
    ptr->kind=BinOpKind;
    ptr->v.BinOp.left=left;
    ptr->v.BinOp.op=op;
    ptr->v.BinOp.right=right;
    ptr->lineno=lineno;
    ptr->col_offset=col_offset;
    return ptr;
};
expr_ty *UnaryOp(unaryop_ty *op,expr_ty *operand,int lineno,int col_offset){
    assert(op!=nullptr);
    assert(operand!=nullptr);
    auto *ptr=new expr_ty();
    ptr->kind=UnaryOpKind;
    ptr->v.UnaryOp.op=op;
    ptr->v.UnaryOp.operand=operand;
    ptr->lineno=lineno;
    ptr->col_offset=col_offset;
    return ptr;
};
expr_ty *Compare(expr_ty *left,asdl_seq<cmpop_ty*> *ops,asdl_seq<expr_ty*> *comparators,int lineno,int col_offset){
    assert(left!=nullptr);
    auto *ptr=new expr_ty();
    ptr->kind=CompareKind;
    ptr->v.Compare.left=left;
    ptr->v.Compare.ops=ops;
    ptr->v.Compare.comparators=comparators;
    ptr->lineno=lineno;
    ptr->col_offset=col_offset;
    return ptr;
};
expr_ty *Call(expr_ty *func,asdl_seq<expr_ty*> *args,asdl_seq<keyword_ty*> *keywords,int lineno,int col_offset){
    assert(func!=nullptr);
    auto *ptr=new expr_ty();
    ptr->kind=CallKind;
    ptr->v.Call.func=func;
    ptr->v.Call.args=args;
    ptr->v.Call.keywords=keywords;
    ptr->lineno=lineno;
    ptr->col_offset=col_offset;
    return ptr;
};
expr_ty *Name(identifier_ty *id,expr_context_ty *ctx,int lineno,int col_offset){
    assert(id!=nullptr);
    assert(ctx!=nullptr);
    auto *ptr=new expr_ty();
    ptr->kind=NameKind;
    ptr->v.Name.id=id;
    ptr->v.Name.ctx=ctx;
    ptr->lineno=lineno;
    ptr->col_offset=col_offset;
    return ptr;
};
expr_ty *NameConstant(singleton_ty *value,int lineno,int col_offset){
    assert(value!=nullptr);
    auto *ptr=new expr_ty();
    ptr->kind=NameConstantKind;
    ptr->v.NameConstant.value=value;
    ptr->lineno=lineno;
    ptr->col_offset=col_offset;
    return ptr;
};
expr_ty *Tuple(asdl_seq<expr_ty*> *elts,expr_context_ty *ctx,int lineno,int col_offset){
    assert(ctx!=nullptr);
    auto *ptr=new expr_ty();
    ptr->kind=TupleKind;
    ptr->v.Tuple.elts=elts;
    ptr->v.Tuple.ctx=ctx;
    ptr->lineno=lineno;
    ptr->col_offset=col_offset;
    return ptr;
};
expr_ty *List(asdl_seq<expr_ty*> *elts,expr_context_ty *ctx,int lineno,int col_offset){
    assert(ctx!=nullptr);
    auto *ptr=new expr_ty();
    ptr->kind=ListKind;
    ptr->v.List.elts=elts;
    ptr->v.List.ctx=ctx;
    ptr->lineno=lineno;
    ptr->col_offset=col_offset;
    return ptr;
};
expr_ty *ListComp(expr_ty *elt,asdl_seq<comprehension_ty*> *generators,int lineno,int col_offset){
    assert(elt!=nullptr);
    auto *ptr=new expr_ty();
    ptr->kind=ListCompKind;
    ptr->v.ListComp.elt=elt;
    ptr->v.ListComp.generators=generators;
    ptr->lineno=lineno;
    ptr->col_offset=col_offset;
    return ptr;
};
expr_ty *Attribute(expr_ty *value,identifier_ty *id,expr_context_ty *ctx,int lineno,int col_offset){
    assert(value!=nullptr);
    assert(id!=nullptr);
    assert(ctx!=nullptr);
    auto *ptr=new expr_ty();
    ptr->kind=AttributeKind;
    ptr->v.Attribute.value=value;
    ptr->v.Attribute.id=id;
    ptr->v.Attribute.ctx=ctx;
    ptr->lineno=lineno;
    ptr->col_offset=col_offset;
    return ptr;
};
expr_ty *Subscript(expr_ty *value,slice_ty *slice,expr_context_ty *ctx,int lineno,int col_offset){
    assert(value!=nullptr);
    assert(slice!=nullptr);
    assert(ctx!=nullptr);
    auto *ptr=new expr_ty();
    ptr->kind=SubscriptKind;
    ptr->v.Subscript.value=value;
    ptr->v.Subscript.slice=slice;
    ptr->v.Subscript.ctx=ctx;
    ptr->lineno=lineno;
    ptr->col_offset=col_offset;
    return ptr;
};
expr_ty *IfExpr(expr_ty *test,expr_ty *body,expr_ty *orelse,int lineno,int col_offset){
    assert(test!=nullptr);
    assert(body!=nullptr);
    assert(orelse!=nullptr);
    auto *ptr=new expr_ty();
    ptr->kind=IfExprKind;
    ptr->v.IfExpr.test=test;
    ptr->v.IfExpr.body=body;
    ptr->v.IfExpr.orelse=orelse;
    ptr->lineno=lineno;
    ptr->col_offset=col_offset;
    return ptr;
};
expr_ty *Dict(asdl_seq<expr_ty*> *keys,asdl_seq<expr_ty*> *values,int lineno,int col_offset){
    auto *ptr=new expr_ty();
    ptr->kind=DictKind;
    ptr->v.Dict.keys=keys;
    ptr->v.Dict.values=values;
    ptr->lineno=lineno;
    ptr->col_offset=col_offset;
    return ptr;
};
expr_ty *Yield(expr_ty *value,int lineno,int col_offset){
    auto *ptr=new expr_ty();
    ptr->kind=YieldKind;
    ptr->v.Yield.value=value;
    ptr->lineno=lineno;
    ptr->col_offset=col_offset;
    return ptr;
};
expr_ty *Num(object_ty *n,int lineno,int col_offset){
    assert(n!=nullptr);
    auto *ptr=new expr_ty();
    ptr->kind=NumKind;
    ptr->v.Num.n=n;
    ptr->lineno=lineno;
    ptr->col_offset=col_offset;
    return ptr;
};
expr_ty *Str(string_ty *s,int lineno,int col_offset){
    assert(s!=nullptr);
    auto *ptr=new expr_ty();
    ptr->kind=StrKind;
    ptr->v.Str.s=s;
    ptr->lineno=lineno;
    ptr->col_offset=col_offset;
    return ptr;
};
expr_ty *Ellipsis(int lineno,int col_offset){
    auto *ptr=new expr_ty();
    ptr->kind=EllipsisKind;
    ptr->lineno=lineno;
    ptr->col_offset=col_offset;
    return ptr;
};
boolop_ty *And(){
    auto *ptr=new boolop_ty();
    ptr->kind=AndKind;
    return ptr;
};
boolop_ty *Or(){
    auto *ptr=new boolop_ty();
    ptr->kind=OrKind;
    return ptr;
};
operator_ty *Add(){
    auto *ptr=new operator_ty();
    ptr->kind=AddKind;
    return ptr;
};
operator_ty *Sub(){
    auto *ptr=new operator_ty();
    ptr->kind=SubKind;
    return ptr;
};
operator_ty *Mult(){
    auto *ptr=new operator_ty();
    ptr->kind=MultKind;
    return ptr;
};
operator_ty *Div(){
    auto *ptr=new operator_ty();
    ptr->kind=DivKind;
    return ptr;
};
operator_ty *Mod(){
    auto *ptr=new operator_ty();
    ptr->kind=ModKind;
    return ptr;
};
operator_ty *Pow(){
    auto *ptr=new operator_ty();
    ptr->kind=PowKind;
    return ptr;
};
operator_ty *LSHIFT(){
    auto *ptr=new operator_ty();
    ptr->kind=LSHIFTKind;
    return ptr;
};
operator_ty *RSHIFT(){
    auto *ptr=new operator_ty();
    ptr->kind=RSHIFTKind;
    return ptr;
};
operator_ty *BitOr(){
    auto *ptr=new operator_ty();
    ptr->kind=BitOrKind;
    return ptr;
};
operator_ty *BitXor(){
    auto *ptr=new operator_ty();
    ptr->kind=BitXorKind;
    return ptr;
};
operator_ty *BitAnd(){
    auto *ptr=new operator_ty();
    ptr->kind=BitAndKind;
    return ptr;
};
operator_ty *FloorDiv(){
    auto *ptr=new operator_ty();
    ptr->kind=FloorDivKind;
    return ptr;
};
unaryop_ty *Invert(){
    auto *ptr=new unaryop_ty();
    ptr->kind=InvertKind;
    return ptr;
};
unaryop_ty *Not(){
    auto *ptr=new unaryop_ty();
    ptr->kind=NotKind;
    return ptr;
};
unaryop_ty *UAdd(){
    auto *ptr=new unaryop_ty();
    ptr->kind=UAddKind;
    return ptr;
};
unaryop_ty *USub(){
    auto *ptr=new unaryop_ty();
    ptr->kind=USubKind;
    return ptr;
};
cmpop_ty *Eq(){
    auto *ptr=new cmpop_ty();
    ptr->kind=EqKind;
    return ptr;
};
cmpop_ty *NotEq(){
    auto *ptr=new cmpop_ty();
    ptr->kind=NotEqKind;
    return ptr;
};
cmpop_ty *Lt(){
    auto *ptr=new cmpop_ty();
    ptr->kind=LtKind;
    return ptr;
};
cmpop_ty *LtE(){
    auto *ptr=new cmpop_ty();
    ptr->kind=LtEKind;
    return ptr;
};
cmpop_ty *Gt(){
    auto *ptr=new cmpop_ty();
    ptr->kind=GtKind;
    return ptr;
};
cmpop_ty *GtE(){
    auto *ptr=new cmpop_ty();
    ptr->kind=GtEKind;
    return ptr;
};
cmpop_ty *Is(){
    auto *ptr=new cmpop_ty();
    ptr->kind=IsKind;
    return ptr;
};
cmpop_ty *IsNot(){
    auto *ptr=new cmpop_ty();
    ptr->kind=IsNotKind;
    return ptr;
};
cmpop_ty *In(){
    auto *ptr=new cmpop_ty();
    ptr->kind=InKind;
    return ptr;
};
cmpop_ty *NotIn(){
    auto *ptr=new cmpop_ty();
    ptr->kind=NotInKind;
    return ptr;
};
expr_context_ty *Load(){
    auto *ptr=new expr_context_ty();
    ptr->kind=LoadKind;
    return ptr;
};
expr_context_ty *Store(){
    auto *ptr=new expr_context_ty();
    ptr->kind=StoreKind;
    return ptr;
};
expr_context_ty *Del(){
    auto *ptr=new expr_context_ty();
    ptr->kind=DelKind;
    return ptr;
};
expr_context_ty *AugLoad(){
    auto *ptr=new expr_context_ty();
    ptr->kind=AugLoadKind;
    return ptr;
};
expr_context_ty *AugStore(){
    auto *ptr=new expr_context_ty();
    ptr->kind=AugStoreKind;
    return ptr;
};
expr_context_ty *Param(){
    auto *ptr=new expr_context_ty();
    ptr->kind=ParamKind;
    return ptr;
};
slice_ty *Slice(expr_ty *lower,expr_ty *upper,expr_ty *step){
    auto *ptr=new slice_ty();
    ptr->kind=SliceKind;
    ptr->v.Slice.lower=lower;
    ptr->v.Slice.upper=upper;
    ptr->v.Slice.step=step;
    return ptr;
};
slice_ty *ExtSlice(asdl_seq<slice_ty*> *dims){
    auto *ptr=new slice_ty();
    ptr->kind=ExtSliceKind;
    ptr->v.ExtSlice.dims=dims;
    return ptr;
};
slice_ty *Index(expr_ty *value){
    assert(value!=nullptr);
    auto *ptr=new slice_ty();
    ptr->kind=IndexKind;
    ptr->v.Index.value=value;
    return ptr;
};
arguments_ty *arguments(asdl_seq<arg_ty*> *args){
    auto *ptr=new arguments_ty();
    ptr->args=args;
    return ptr;
}
arg_ty *arg(identifier_ty *args,int lineno,int col_offset){
    assert(args!=nullptr);
    auto *ptr=new arg_ty();
    ptr->args=args;
    ptr->lineno=lineno;
    ptr->col_offset=col_offset;
    return ptr;
}
keyword_ty *keyword(identifier_ty *arg,expr_ty *value){
    assert(value!=nullptr);
    auto *ptr=new keyword_ty();
    ptr->arg=arg;
    ptr->value=value;
    return ptr;
}
comprehension_ty *comprehension(expr_ty *target,expr_ty *iter,asdl_seq<expr_ty*> *ifs){
    assert(target!=nullptr);
    assert(iter!=nullptr);
    auto *ptr=new comprehension_ty();
    ptr->target=target;
    ptr->iter=iter;
    ptr->ifs=ifs;
    return ptr;
}
