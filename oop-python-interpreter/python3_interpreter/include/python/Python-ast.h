/*.h generated by asdl*/

#pragma once
#include "common.h"
#include "asdl.h"

struct mod_ty;
struct stmt_ty;
struct expr_ty;
struct boolop_ty;
struct operator_ty;
struct unaryop_ty;
struct cmpop_ty;
struct expr_context_ty;
struct slice_ty;
struct arguments_ty;
struct arg_ty;
struct keyword_ty;

enum mod_ty_enum{
    ModuleKind,
    InteractiveKind,
    ExpressionKind,
};
struct mod_ty{
    mod_ty_enum kind;
    union{
        struct{
            asdl_seq<stmt_ty*> *body;
            string_ty *docstring;
        } Module;
        struct{
            asdl_seq<stmt_ty*> *body;
        } Interactive;
        struct{
            expr_ty *body;
        } Expression;
    } v;
    auto Module()->decltype(&v.Module);
    auto Interactive()->decltype(&v.Interactive);
    auto Expression()->decltype(&v.Expression);
};
enum stmt_ty_enum{
    FunctionDefKind,
    ReturnKind,
    AssignKind,
    AugAssignKind,
    ForKind,
    WhileKind,
    IfKind,
    ExprKind,
    PassKind,
    BreakKind,
    ContinueKind,
};
struct stmt_ty{
    stmt_ty_enum kind;
    union{
        struct{
            identifier_ty *name;
            arguments_ty *args;
            asdl_seq<stmt_ty*> *body;
        } FunctionDef;
        struct{
            expr_ty *value;
        } Return;
        struct{
            asdl_seq<expr_ty*> *targets;
            expr_ty *value;
        } Assign;
        struct{
            expr_ty *target;
            operator_ty *op;
            expr_ty *value;
        } AugAssign;
        struct{
            expr_ty *target;
            expr_ty *iter;
            asdl_seq<stmt_ty*> *body;
            asdl_seq<stmt_ty*> *orelse;
        } For;
        struct{
            expr_ty *test;
            asdl_seq<stmt_ty*> *body;
            asdl_seq<stmt_ty*> *orelse;
        } While;
        struct{
            expr_ty *test;
            asdl_seq<stmt_ty*> *body;
            asdl_seq<stmt_ty*> *orelse;
        } If;
        struct{
            expr_ty *value;
        } Expr;
        struct{
        } Pass;
        struct{
        } Break;
        struct{
        } Continue;
    } v;
    auto FunctionDef()->decltype(&v.FunctionDef);
    auto Return()->decltype(&v.Return);
    auto Assign()->decltype(&v.Assign);
    auto AugAssign()->decltype(&v.AugAssign);
    auto For()->decltype(&v.For);
    auto While()->decltype(&v.While);
    auto If()->decltype(&v.If);
    auto Expr()->decltype(&v.Expr);
    int lineno;
    int col_offset;
};
enum expr_ty_enum{
    BoolOpKind,
    BinOpKind,
    UnaryOpKind,
    CompareKind,
    CallKind,
    NameKind,
    NameConstantKind,
    TupleKind,
    AttributeKind,
    SubscriptKind,
    NumKind,
    StrKind,
    EllipsisKind,
};
struct expr_ty{
    expr_ty_enum kind;
    union{
        struct{
            boolop_ty *op;
            asdl_seq<expr_ty*> *values;
        } BoolOp;
        struct{
            expr_ty *left;
            operator_ty *op;
            expr_ty *right;
        } BinOp;
        struct{
            unaryop_ty *op;
            expr_ty *operand;
        } UnaryOp;
        struct{
            expr_ty *left;
            asdl_seq<cmpop_ty*> *ops;
            asdl_seq<expr_ty*> *comparators;
        } Compare;
        struct{
            expr_ty *func;
            asdl_seq<expr_ty*> *args;
            asdl_seq<keyword_ty*> *keywords;
        } Call;
        struct{
            identifier_ty *id;
            expr_context_ty *ctx;
        } Name;
        struct{
            singleton_ty *value;
        } NameConstant;
        struct{
            asdl_seq<expr_ty*> *elts;
            expr_context_ty *ctx;
        } Tuple;
        struct{
            expr_ty *value;
            identifier_ty *id;
            expr_context_ty *ctx;
        } Attribute;
        struct{
            expr_ty *value;
            slice_ty *slice;
            expr_context_ty *ctx;
        } Subscript;
        struct{
            object_ty *n;
        } Num;
        struct{
            string_ty *s;
        } Str;
        struct{
        } Ellipsis;
    } v;
    auto BoolOp()->decltype(&v.BoolOp);
    auto BinOp()->decltype(&v.BinOp);
    auto UnaryOp()->decltype(&v.UnaryOp);
    auto Compare()->decltype(&v.Compare);
    auto Call()->decltype(&v.Call);
    auto Name()->decltype(&v.Name);
    auto NameConstant()->decltype(&v.NameConstant);
    auto Tuple()->decltype(&v.Tuple);
    auto Attribute()->decltype(&v.Attribute);
    auto Subscript()->decltype(&v.Subscript);
    auto Num()->decltype(&v.Num);
    auto Str()->decltype(&v.Str);
    int lineno;
    int col_offset;
};
enum boolop_ty_enum{
    AndKind,
    OrKind,
};
struct boolop_ty{
    boolop_ty_enum kind;
    union{
    } v;
};
enum operator_ty_enum{
    AddKind,
    SubKind,
    MultKind,
    DivKind,
    ModKind,
    PowKind,
    LSHIFTKind,
    RSHIFTKind,
    BitOrKind,
    BitXorKind,
    BitAndKind,
    FloorDivKind,
};
struct operator_ty{
    operator_ty_enum kind;
    union{
    } v;
};
enum unaryop_ty_enum{
    InvertKind,
    NotKind,
    UAddKind,
    USubKind,
};
struct unaryop_ty{
    unaryop_ty_enum kind;
    union{
    } v;
};
enum cmpop_ty_enum{
    EqKind,
    NotEqKind,
    LtKind,
    LtEKind,
    GtKind,
    GtEKind,
    IsKind,
    IsNotKind,
    InKind,
    NotInKind,
};
struct cmpop_ty{
    cmpop_ty_enum kind;
    union{
    } v;
};
enum expr_context_ty_enum{
    LoadKind,
    StoreKind,
    DelKind,
    AugLoadKind,
    AugStoreKind,
    ParamKind,
};
struct expr_context_ty{
    expr_context_ty_enum kind;
    union{
    } v;
};
enum slice_ty_enum{
    SliceKind,
    ExtSliceKind,
    IndexKind,
};
struct slice_ty{
    slice_ty_enum kind;
    union{
        struct{
            expr_ty *lower;
            expr_ty *upper;
            expr_ty *step;
        } Slice;
        struct{
            asdl_seq<slice_ty*> *dims;
        } ExtSlice;
        struct{
            expr_ty *value;
        } Index;
    } v;
    auto Slice()->decltype(&v.Slice);
    auto ExtSlice()->decltype(&v.ExtSlice);
    auto Index()->decltype(&v.Index);
};
struct arguments_ty{
    asdl_seq<arg_ty*> *args;
};
struct arg_ty{
    identifier_ty *args;
    int lineno;
    int col_offset;
};
struct keyword_ty{
    identifier_ty *arg;
    expr_ty *value;
};
mod_ty *Module(asdl_seq<stmt_ty*> *body,string_ty *docstring);
mod_ty *Interactive(asdl_seq<stmt_ty*> *body);
mod_ty *Expression(expr_ty *body);
stmt_ty *FunctionDef(identifier_ty *name,arguments_ty *args,asdl_seq<stmt_ty*> *body,int lineno,int col_offset);
stmt_ty *Return(expr_ty *value,int lineno,int col_offset);
stmt_ty *Assign(asdl_seq<expr_ty*> *targets,expr_ty *value,int lineno,int col_offset);
stmt_ty *AugAssign(expr_ty *target,operator_ty *op,expr_ty *value,int lineno,int col_offset);
stmt_ty *For(expr_ty *target,expr_ty *iter,asdl_seq<stmt_ty*> *body,asdl_seq<stmt_ty*> *orelse,int lineno,int col_offset);
stmt_ty *While(expr_ty *test,asdl_seq<stmt_ty*> *body,asdl_seq<stmt_ty*> *orelse,int lineno,int col_offset);
stmt_ty *If(expr_ty *test,asdl_seq<stmt_ty*> *body,asdl_seq<stmt_ty*> *orelse,int lineno,int col_offset);
stmt_ty *Expr(expr_ty *value,int lineno,int col_offset);
stmt_ty *Pass(int lineno,int col_offset);
stmt_ty *Break(int lineno,int col_offset);
stmt_ty *Continue(int lineno,int col_offset);
expr_ty *BoolOp(boolop_ty *op,asdl_seq<expr_ty*> *values,int lineno,int col_offset);
expr_ty *BinOp(expr_ty *left,operator_ty *op,expr_ty *right,int lineno,int col_offset);
expr_ty *UnaryOp(unaryop_ty *op,expr_ty *operand,int lineno,int col_offset);
expr_ty *Compare(expr_ty *left,asdl_seq<cmpop_ty*> *ops,asdl_seq<expr_ty*> *comparators,int lineno,int col_offset);
expr_ty *Call(expr_ty *func,asdl_seq<expr_ty*> *args,asdl_seq<keyword_ty*> *keywords,int lineno,int col_offset);
expr_ty *Name(identifier_ty *id,expr_context_ty *ctx,int lineno,int col_offset);
expr_ty *NameConstant(singleton_ty *value,int lineno,int col_offset);
expr_ty *Tuple(asdl_seq<expr_ty*> *elts,expr_context_ty *ctx,int lineno,int col_offset);
expr_ty *Attribute(expr_ty *value,identifier_ty *id,expr_context_ty *ctx,int lineno,int col_offset);
expr_ty *Subscript(expr_ty *value,slice_ty *slice,expr_context_ty *ctx,int lineno,int col_offset);
expr_ty *Num(object_ty *n,int lineno,int col_offset);
expr_ty *Str(string_ty *s,int lineno,int col_offset);
expr_ty *Ellipsis(int lineno,int col_offset);
boolop_ty *And();
boolop_ty *Or();
operator_ty *Add();
operator_ty *Sub();
operator_ty *Mult();
operator_ty *Div();
operator_ty *Mod();
operator_ty *Pow();
operator_ty *LSHIFT();
operator_ty *RSHIFT();
operator_ty *BitOr();
operator_ty *BitXor();
operator_ty *BitAnd();
operator_ty *FloorDiv();
unaryop_ty *Invert();
unaryop_ty *Not();
unaryop_ty *UAdd();
unaryop_ty *USub();
cmpop_ty *Eq();
cmpop_ty *NotEq();
cmpop_ty *Lt();
cmpop_ty *LtE();
cmpop_ty *Gt();
cmpop_ty *GtE();
cmpop_ty *Is();
cmpop_ty *IsNot();
cmpop_ty *In();
cmpop_ty *NotIn();
expr_context_ty *Load();
expr_context_ty *Store();
expr_context_ty *Del();
expr_context_ty *AugLoad();
expr_context_ty *AugStore();
expr_context_ty *Param();
slice_ty *Slice(expr_ty *lower,expr_ty *upper,expr_ty *step);
slice_ty *ExtSlice(asdl_seq<slice_ty*> *dims);
slice_ty *Index(expr_ty *value);
arguments_ty *arguments(asdl_seq<arg_ty*> *args);
arg_ty *arg(identifier_ty *args,int lineno,int col_offset);
keyword_ty *keyword(identifier_ty *arg,expr_ty *value);
